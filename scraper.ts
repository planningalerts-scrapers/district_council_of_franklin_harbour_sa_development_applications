// Parses the development applications at the South Australian District Council of Franklin Harbour
// web site and places them in a database.
//
// Michael Bone
// 22nd April 2019

"use strict";

import * as fs from "fs";

// Suppress the "pre-main prep time" messages generated by tesseract.js (there is no other easy
// way to suppress these messages because it appears that the code runs in a separate process and
// so, for example, overriding console.log in the current process appears to have no effect).

let text = fs.readFileSync("node_modules/tesseract.js-core/index.js").toString().replace(/Module.\$a\("pre-main prep time\: "\+\(Date\.now\(\)\-tj\)\+" ms"\)/g, "true");
fs.writeFileSync("node_modules/tesseract.js-core/index.js", text);

import * as cheerio from "cheerio";
import * as request from "request-promise-native";
import * as sqlite3 from "sqlite3";
import * as urlparser from "url";
import * as moment from "moment";
import * as pdfjs from "pdfjs-dist";
import * as tesseract from "tesseract.js";
import * as jimp from "jimp";
import didYouMean, * as didyoumean from "didyoumean2";

sqlite3.verbose();

const DevelopmentApplicationsUrl = "https://www.franklinharbour.sa.gov.au/services/development";
const CommentUrl = "mailto:council@franklinharbour.sa.gov.au";

declare const global: any;
declare const process: any;

const Tolerance = 3;
const WhiteThreshold = 232;

// All valid street names, street suffixes, suburb names and hundred names.

let SuburbNames = null;
let StreetSuffixes = null;
let StreetNames = null;
let HundredNames = null;

// Sets up an sqlite database.

async function initializeDatabase() {
    return new Promise((resolve, reject) => {
        let database = new sqlite3.Database("data.sqlite");
        database.serialize(() => {
            database.run("create table if not exists [data] ([council_reference] text primary key, [address] text, [description] text, [info_url] text, [comment_url] text, [date_scraped] text, [date_received] text)");
            resolve(database);
        });
    });
}

// Inserts a row in the database if it does not already exist.

async function insertRow(database, developmentApplication) {
    return new Promise((resolve, reject) => {
        let sqlStatement = database.prepare("insert or replace into [data] values (?, ?, ?, ?, ?, ?, ?)");
        sqlStatement.run([
            developmentApplication.applicationNumber,
            developmentApplication.address,
            developmentApplication.description,
            developmentApplication.informationUrl,
            developmentApplication.commentUrl,
            developmentApplication.scrapeDate,
            developmentApplication.receivedDate
        ], function(error, row) {
            if (error) {
                console.error(error);
                reject(error);
            } else {
                console.log(`    Saved application \"${developmentApplication.applicationNumber}\" with address \"${developmentApplication.address}\", description \"${developmentApplication.description}\" and received date \"${developmentApplication.receivedDate}\" to the database.`);
                sqlStatement.finalize();  // releases any locks
                resolve(row);
            }
        });
    });
}

// A bounding rectangle.

interface Rectangle {
    x: number,
    y: number,
    width: number,
    height: number
}

// A 2D point.

interface Point {
    x: number,
    y: number
}

// An element (consisting of text and a bounding rectangle) in a PDF document.

interface Element extends Rectangle {
    text: string,
    confidence: number
}

// An image and its bounding rectangle.

interface ImageInfo {
    image: any,
    bounds: Rectangle
}

// Rotates a rectangle clockwise.

const Origin: Point = { x: 0, y: 0 };

function rotateImage(bounds: Rectangle, degrees: number) {
    if (degrees !== 90)
        return { ...bounds };
    
    return {
        x: Origin.y - bounds.y - bounds.height,
        y: bounds.x - Origin.x,
        width: bounds.height,
        height: bounds.width
    }
}

// Constructs a rectangle based on the union of the two specified rectangles.

function union(rectangle1: Rectangle, rectangle2: Rectangle): Rectangle {
    if (rectangle1 === undefined && rectangle2 === undefined)
        return undefined;
    else if (rectangle1 === undefined)
        return { ...rectangle2 };
    else if (rectangle2 === undefined)
        return { ...rectangle1 };

    let x = Math.min(rectangle1.x, rectangle2.x);
    let y = Math.min(rectangle1.y, rectangle1.y);
    let width = Math.max(Math.max(rectangle1.x + rectangle1.width, rectangle2.x + rectangle2.width) - x, 0);
    let height = Math.max(Math.max(rectangle1.y + rectangle1.height, rectangle2.y + rectangle2.height) - y, 0);
    return { x: x, y: y, width: width, height: height };
}

// Constructs a rectangle based on the intersection of the two specified rectangles.

function intersect(rectangle1: Rectangle, rectangle2: Rectangle): Rectangle {
    let x1 = Math.max(rectangle1.x, rectangle2.x);
    let y1 = Math.max(rectangle1.y, rectangle2.y);
    let x2 = Math.min(rectangle1.x + rectangle1.width, rectangle2.x + rectangle2.width);
    let y2 = Math.min(rectangle1.y + rectangle1.height, rectangle2.y + rectangle2.height);
    if (x2 >= x1 && y2 >= y1)
        return { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };
    else
        return { x: 0, y: 0, width: 0, height: 0 };
}

// Calculates the fraction of an element that lies within a rectangle (as a percentage).  For
// example, if a quarter of the specified element lies within the specified rectangle then this
// would return 25.

function getPercentageOfElementInRectangle(element: Element, rectangle: Rectangle) {
    let elementArea = getArea(element);
    let intersectionArea = getArea(intersect(rectangle, element));
    return (elementArea === 0) ? 0 : ((intersectionArea * 100) / elementArea);
}

// Calculates the area of a rectangle.

function getArea(rectangle: Rectangle) {
    return rectangle.width * rectangle.height;
}

// Calculates the square of the distance between two elements.

function calculateDistance(element1: Element, element2: Element) {
    let point1 = { x: element1.x + element1.width, y: element1.y + element1.height / 2 };
    let point2 = { x: element2.x, y: element2.y + element2.height / 2 };
    if (point2.x < point1.x - element1.width / 5)  // arbitrary overlap factor of 20% (ie. ignore elements that overlap too much in the horizontal direction)
        return Number.MAX_VALUE;
    return (point2.x - point1.x) * (point2.x - point1.x) + (point2.y - point1.y) * (point2.y - point1.y);
}

// Determines whether there is vertical overlap between two elements.

function isVerticalOverlap(element1: Element, element2: Element) {
    return element2.y < element1.y + element1.height && element2.y + element2.height > element1.y;
}

// Gets the percentage of vertical overlap between two elements (0 means no overlap and 100 means
// 100% overlap; and, for example, 20 means that 20% of the second element overlaps somewhere
// with the first element).

function getVerticalOverlapPercentage(element1: Element, element2: Element) {
    let y1 = Math.max(element1.y, element2.y);
    let y2 = Math.min(element1.y + element1.height, element2.y + element2.height);
    return (y2 < y1) ? 0 : (((y2 - y1) * 100) / element2.height);
}

// Gets the element immediately to the right of the specified element (but ignores elements that
// appear after a large horizontal gap).

function getRightElement(elements: Element[], element: Element) {
    let closestElement: Element = { text: undefined, confidence: 0, x: Number.MAX_VALUE, y: Number.MAX_VALUE, width: 0, height: 0 };
    for (let rightElement of elements)
        if (isVerticalOverlap(element, rightElement) &&  // ensure that there is at least some vertical overlap
            getVerticalOverlapPercentage(element, rightElement) > 50 &&  // avoid extremely tall elements (ensure at least 50% overlap)
            (rightElement.x > element.x + element.width) &&  // ensure the element actually is to the right
            (rightElement.x - (element.x + element.width) < 30) &&  // avoid elements that appear after a large gap (arbitrarily ensure less than a 30 pixel gap horizontally)
            calculateDistance(element, rightElement) < calculateDistance(element, closestElement))  // check if closer than any element encountered so far
            closestElement = rightElement;
    return (closestElement.text === undefined) ? undefined : closestElement;
}

// Reads all the address information into global objects.

function readAddressInformation() {
    StreetNames = {};
    for (let line of fs.readFileSync("streetnames.txt").toString().replace(/\r/g, "").trim().split("\n")) {
        let streetNameTokens = line.toUpperCase().split(",");
        let streetName = streetNameTokens[0].trim();
        let suburbName = streetNameTokens[1].trim();
        (StreetNames[streetName] || (StreetNames[streetName] = [])).push(suburbName);  // several suburbs may exist for the same street name
    }

    StreetSuffixes = {};
    for (let line of fs.readFileSync("streetsuffixes.txt").toString().replace(/\r/g, "").trim().split("\n")) {
        let streetSuffixTokens = line.toUpperCase().split(",");
        StreetSuffixes[streetSuffixTokens[0].trim()] = streetSuffixTokens[1].trim();
    }

    SuburbNames = {};
    for (let line of fs.readFileSync("suburbnames.txt").toString().replace(/\r/g, "").trim().split("\n")) {
        let suburbTokens = line.toUpperCase().split(",");
        SuburbNames[suburbTokens[0].trim()] = suburbTokens[1].trim();
    }

    HundredNames = [];
    for (let line of fs.readFileSync("hundrednames.txt").toString().replace(/\r/g, "").trim().split("\n"))
        HundredNames.push(line.trim().toUpperCase());
}

// Segments an image vertically and horizontally based on blocks of white (or almost white) pixels
// in order to avoid using too much memory.  Very often a large image will be mostly white space.
// A very simplistic horizontal and then vertical search is performed for consecutive lines of
// white (or mostly white) pixels.

function segmentImage(jimpImage: any) {
    let bounds = { x: 0, y: 0, width: jimpImage.bitmap.width, height: jimpImage.bitmap.height };
       
    // Segment the image based on white space.

    let rectangles: Rectangle[] = [];
    let horizontalRectangles: Rectangle[] = [];
    let verticalRectangles = segmentImageVertically(jimpImage, bounds);
    for (let verticalRectangle of verticalRectangles)
        horizontalRectangles = horizontalRectangles.concat(segmentImageHorizontally(jimpImage, verticalRectangle));
    for (let horizontalRectangle of horizontalRectangles)
        rectangles = rectangles.concat(segmentImageVertically(jimpImage, horizontalRectangle));  // repeat the segmentation vertically on the sub-images (because this may then produce even smaller images)

    // Extract images delineated by the white space.

    let segments: ImageInfo[] = [];
    for (let rectangle of rectangles) {
        let croppedJimpImage: jimp = new (jimp as any)(rectangle.width, rectangle.height);
        croppedJimpImage.blit(jimpImage, 0, 0, rectangle.x, rectangle.y, rectangle.width, rectangle.height);            
        segments.push({ image: croppedJimpImage, bounds: rectangle });
    }
    return segments;
}

// Segments an image vertically (within the specified bounds) by searching for blocks of
// consecutive, white (or close to white) horizontal lines.

function segmentImageVertically(jimpImage: any, bounds: Rectangle) {
    let whiteBlocks = [];

    let isPreviousWhiteLine = false;
    for (let y = bounds.y; y < bounds.y + bounds.height; y++) {
        // Count the number of white pixels across the current horizontal line.

        let whiteCount = 0;
        for (let x = bounds.x; x < bounds.x + bounds.width; x++) {
            let value = jimpImage.getPixelColor(x, y);
            if (value === 0xffffffff)  // performance improvement (for the common case of a pure white pixel)
                whiteCount++;
            else {
                let color = (jimp as any).intToRGBA(value);
                if (color.r > WhiteThreshold && color.g > WhiteThreshold && color.b > WhiteThreshold)  // white or just off-white
                    whiteCount++;
            }
        }

        // If the line is mostly white pixels then it is considered a white line.

        let isWhiteLine = (whiteCount >= bounds.width - 2);  // allow up to two non-white pixels

        if (isWhiteLine) {
            if (isPreviousWhiteLine)
                whiteBlocks[whiteBlocks.length - 1].height++;  // increase the size of the current block of white
            else
                whiteBlocks.push({ y: y, height: 1 });  // start a new block
        }

        isPreviousWhiteLine = isWhiteLine;
    }

    // Only keep blocks of white that consist of 20 consecutive lines or more (an arbitrary value).

    whiteBlocks = whiteBlocks.filter(whiteBlock => whiteBlock.height >= 20);

    // Determine the rectangles that remain when the blocks of white are removed.

    let rectangles = [];
    for (let index = 0; index <= whiteBlocks.length; index++) {
        let y = (index === 0) ? bounds.y : (whiteBlocks[index - 1].y + whiteBlocks[index - 1].height);
        let height = ((index === whiteBlocks.length) ? (bounds.y + bounds.height) : whiteBlocks[index].y) - y;
        if (height > 0)
            rectangles.push({ x: bounds.x, y: y, width: bounds.width, height: height });
    }

    return rectangles;
}

// Segments an image horizontally (within the specified bounds) by searching for blocks of
// consecutive, white (or close to white) vertical lines.

function segmentImageHorizontally(jimpImage: any, bounds: Rectangle) {
    let whiteBlocks = [];

    let isPreviousWhiteLine = false;
    for (let x = bounds.x; x < bounds.x + bounds.width; x++) {
        // Count the number of white pixels across the current vertical line.

        let whiteCount = 0;
        for (let y = bounds.y; y < bounds.y + bounds.height; y++) {
            let value = jimpImage.getPixelColor(x, y);
            if (value === 0xffffffff)  // performance improvement (for the common case of a pure white pixel)
                whiteCount++;
            else {
                let color = (jimp as any).intToRGBA(value);
                if (color.r > WhiteThreshold && color.g > WhiteThreshold && color.b > WhiteThreshold)  // white or just off-white
                    whiteCount++;
            }
        }

        // If the line is mostly white pixels then it is considered a white line.

        let isWhiteLine = (whiteCount >= bounds.height - 2);  // allow up to two non-white pixels

        if (isWhiteLine) {
            if (isPreviousWhiteLine)
                whiteBlocks[whiteBlocks.length - 1].width++;  // increase the size of the current block of white
            else
                whiteBlocks.push({ x: x, width: 1 });  // start a new block
        }

        isPreviousWhiteLine = isWhiteLine;
    }

    // Only keep blocks of white that consist of 20 consecutive lines or more (an arbitrary value).

    whiteBlocks = whiteBlocks.filter(whiteBlock => whiteBlock.width >= 20);

    // Determine the bounds of the rectangles that remain when the blocks of white are removed.

    let rectangles = [];
    for (let index = 0; index <= whiteBlocks.length; index++) {
        let x = (index === 0) ? bounds.x : (whiteBlocks[index - 1].x + whiteBlocks[index - 1].width);
        let width = ((index === whiteBlocks.length) ? (bounds.x + bounds.width) : whiteBlocks[index].x) - x;
        if (width > 0)
            rectangles.push({ x: x, y: bounds.y, width: width, height: bounds.height });
    }

    return rectangles;
}

// Finds all elements that closely match the specified text and returns rectangles that encompass
// each set of matching elements.

function findAllTextBounds(elements: Element[], text: string) {
    let condensedText = text.replace(/[^A-Za-z0-9\s]/g, "").toLowerCase();

    // Examine all elements on the page.

    let matches: Rectangle[] = [];
    for (let element of elements) {
        // Extract up to 5 elements to the right of the element.  Join together the elements to
        // the right in an attempt to find a match to the text.

        let rightElement = element;
        let rightElements: Element[] = [];

        do {
            rightElements.push(rightElement);
            let currentText = rightElements.map(element => element.text).join("").replace(/[^A-Za-z0-9\s]/g, "").toLowerCase();

            if (currentText.length > condensedText.length + 3)  // stop once the text is too long
                break;
            if (currentText.length >= condensedText.length - 3) {  // ignore until the text is close to long enough
                if (currentText === condensedText || didYouMean(currentText, [ condensedText ], { caseSensitive: false, returnType: didyoumean.ReturnTypeEnums.FIRST_CLOSEST_MATCH, thresholdType: didyoumean.ThresholdTypeEnums.EDIT_DISTANCE, threshold: 2, trimSpaces: true }) !== null) {
                    // Construct an encompassing rectangle.

                    let rectangle = undefined;
                    for (let rightElement of rightElements)
                        rectangle = union(rectangle, rightElement);

                    matches.push({ x: rectangle.x, y: rectangle.y, width: rectangle.width, height: rectangle.height });
                }
            }

            rightElement = getRightElement(elements, rightElement);
        } while (rightElement !== undefined && rightElements.length < 5);  // up to 5 elements
    }

    return matches;
}

// Finds the elements that most closely match the specified text and returns a rectangle that
// encompasses all of those elements.

function findTextBounds(elements: Element[], text: string) {
    // Examine all elements on the page.

    let condensedText = text.replace(/[^A-Za-z0-9\s]/g, "").toLowerCase();

    let matches = [];
    for (let element of elements) {
        // Extract up to 5 elements to the right of the element that has text starting with the
        // required character (and so may be the start of the requested text).  Join together the
        // elements to the right in an attempt to find the best match to the text.

        let rightElement = element;
        let rightElements: Element[] = [];

        do {
            rightElements.push(rightElement);

            let currentText = rightElements.map(element => element.text).join("").replace(/[^A-Za-z0-9\s]/g, "").toLowerCase();

            if (currentText.length > condensedText.length + 3)  // stop once the text is too long
                break;
            if (currentText.length >= condensedText.length - 3) {  // ignore until the text is close to long enough
                if (currentText === condensedText)
                    matches.push({ elements: [...rightElements], threshold: 0, text: currentText });
                else if (didYouMean(currentText, [ condensedText ], { caseSensitive: false, returnType: didyoumean.ReturnTypeEnums.FIRST_CLOSEST_MATCH, thresholdType: didyoumean.ThresholdTypeEnums.EDIT_DISTANCE, threshold: 1, trimSpaces: true }) !== null)
                    matches.push({ elements: [...rightElements], threshold: 1, text: currentText });
                else if (didYouMean(currentText, [ condensedText ], { caseSensitive: false, returnType: didyoumean.ReturnTypeEnums.FIRST_CLOSEST_MATCH, thresholdType: didyoumean.ThresholdTypeEnums.EDIT_DISTANCE, threshold: 2, trimSpaces: true }) !== null)
                    matches.push({ elements: [...rightElements], threshold: 2, text: currentText });
                else if (didYouMean(currentText, [ condensedText ], { caseSensitive: false, returnType: didyoumean.ReturnTypeEnums.FIRST_CLOSEST_MATCH, thresholdType: didyoumean.ThresholdTypeEnums.EDIT_DISTANCE, threshold: 3, trimSpaces: true }) !== null)
                    matches.push({ elements: [...rightElements], threshold: 3, text: currentText });
                else if (didYouMean(currentText, [ condensedText ], { caseSensitive: false, returnType: didyoumean.ReturnTypeEnums.FIRST_CLOSEST_MATCH, thresholdType: didyoumean.ThresholdTypeEnums.EDIT_DISTANCE, threshold: 4, trimSpaces: true }) !== null)
                    matches.push({ elements: [...rightElements], threshold: 4, text: currentText });
            }

            rightElement = getRightElement(elements, rightElement);
        } while (rightElement !== undefined && rightElements.length < 5);  // up to 5 elements
    }

    // Choose the best match (if any matches were found).  Note that trimming is performed here so
    // that text such as "  Plan" is matched in preference to text such as "plan)" (when looking
    // for elements that match "Plan").  For an example of this problem see "200/303/07" in
    // "https://www.walkerville.sa.gov.au/webdata/resources/files/DA%20Register%20-%202007.pdf".

    if (matches.length > 0) {
        let bestMatch = matches.reduce((previous, current) =>
            (previous === undefined ||
            current.threshold < previous.threshold ||
            (current.threshold === previous.threshold && Math.abs(current.text.trim().length - condensedText.length) < Math.abs(previous.text.trim().length - condensedText.length)) ? current : previous), undefined);

        // Union together the rectangles of all elements belonging to the best match.

        let rectangle = undefined;
        for (let element of bestMatch.elements)
            rectangle = (rectangle === undefined) ? element : union(rectangle, element);
        return { x: rectangle.x, y: rectangle.y, width: rectangle.width, height: rectangle.height };
    }

    return undefined;
}

// Converts image data from the PDF to a jimp format image (with the specified rotation).

function convertToJimpImage(image: any, degrees: number) {
    let pixelSize = (8 * image.data.length) / (image.width * image.height);
    let jimpImage = new (jimp as any)(image.width, image.height, 0xffffffff);  // solid white image

    if (pixelSize === 1) {        
        // A monochrome image (one bit per pixel).

        let black = jimp.rgbaToInt(0, 0, 0, 255);  // black pixel
        for (let x = 0; x < image.width; x++) {
            for (let y = 0; y < image.height; y++) {
                let index = y * (image.width / 8);
                let bitIndex = x % 8;
                let byteIndex = (x - bitIndex) / 8;
                index += byteIndex;
                if ((image.data[index] & (128 >> bitIndex)) === 0)
                    jimpImage.setPixelColor(black, x, y);
            }
        }
    } else {
        // Assume a 24 bit colour image (3 bytes per pixel).

        for (let x = 0; x < image.width; x++) {
            for (let y = 0; y < image.height; y++) {
                let index = (y * image.width * 3) + (x * 3);
                let r = image.data[index];
                let g = image.data[index + 1];
                let b = image.data[index + 2];
                if (r < WhiteThreshold || g < WhiteThreshold || b < WhiteThreshold)  // only ignore white and practically white
                    jimpImage.setPixelColor(jimp.rgbaToInt(r, g, b, 255), x, y);
            }
        }
    }

    jimpImage.rotate(degrees);
    return jimpImage;
}

// Parses text from an image (using the specified language).

async function parseImage(image: any, bounds: Rectangle, language: string) {
    // Segment the image based on blocks of white.

    let segments = segmentImage(image);
    if (global.gc)
        global.gc();

    let elements: Element[] = [];
    for (let segment of segments) {
        let scaleFactor = 1.0;  // currently always 1.0

        let imageBuffer = await new Promise((resolve, reject) => segment.image.getBuffer(jimp.MIME_PNG, (error, buffer) => error ? reject(error) : resolve(buffer)));
        segment.image = undefined;  // attempt to release memory

        // Report larger memory usage and larger images for troubleshooting purposes.

        let memoryUsage = process.memoryUsage();
        if (memoryUsage.rss > 200 * 1024 * 1024)  // 200 MB
            console.log(`    Memory Usage: rss: ${Math.round(memoryUsage.rss / (1024 * 1024))} MB, heapTotal: ${Math.round(memoryUsage.heapTotal / (1024 * 1024))} MB, heapUsed: ${Math.round(memoryUsage.heapUsed / (1024 * 1024))} MB, external: ${Math.round(memoryUsage.external / (1024 * 1024))} MB`);
        if (segment.bounds.width * scaleFactor * segment.bounds.height * scaleFactor > 700 * 700)
            console.log(`    Parsing a large image segment with width ${Math.round(segment.bounds.width * scaleFactor)} and height ${Math.round(segment.bounds.height * scaleFactor)}.`);

        // Note that textord_old_baselines is set to 0 so that text that is offset by half the
        // height of the the font is correctly recognised.

        let result: any = await new Promise((resolve, reject) => { tesseract.recognize(imageBuffer, { lang: language, textord_old_baselines: "0" }).then(function(result) { resolve(result); }) });

        tesseract.terminate();
        if (global.gc)
            global.gc();

        // Simplify the lines (remove most of the information generated by tesseract.js).

        if (result && result.blocks && result.blocks.length)
            for (let block of result.blocks)
                for (let paragraph of block.paragraphs)
                    for (let line of paragraph.lines)
                        elements = elements.concat(line.words.map(word => {
                            return {
                                text: word.text,
                                confidence: word.confidence,
                                choiceCount: word.choices.length,
                                x: bounds.x + segment.bounds.x + word.bbox.x0 / scaleFactor,
                                y: bounds.y + segment.bounds.y + word.bbox.y0 / scaleFactor,
                                width: (word.bbox.x1 - word.bbox.x0) / scaleFactor,
                                height: (word.bbox.y1 - word.bbox.y0) / scaleFactor
                            };
                        }));
    }

    return elements;
}

// Parses a PDF document.

async function parsePdf(url: string) {
    // Read the PDF.

    let buffer = await request({ url: url, encoding: null, proxy: process.env.MORPH_PROXY });
    await sleep(2000 + getRandom(0, 5) * 1000);

    // Parse the PDF.  Each page has the details of multiple applications.  Note that the PDF is
    // re-parsed on each iteration of the loop (ie. once for each page).  This then avoids large
    // memory usage by the PDF (because just calling page._destroy() on each iteration of the loop
    // appears not to be enough to release all memory used by the PDF parsing).

    let elements: Element[] = [];

    let permitNumberHeadingBounds: Rectangle = undefined;
    let applicantsDetailsHeadingBounds: Rectangle = undefined;
    let siteOfBuildingHeadingBounds: Rectangle = undefined;
    let descriptionOfWorkHeadingBounds: Rectangle = undefined;

    console.log("Testing with just one page.");
    for (let pageIndex = 0; pageIndex < 500; pageIndex++) {  // limit to an arbitrarily large number of pages (to avoid any chance of an infinite loop)
        let pdf = await pdfjs.getDocument({ data: buffer, disableFontFace: true, ignoreErrors: true });
        if (pageIndex >= pdf.numPages)
            break;

        console.log(`Reading and parsing applications from page ${pageIndex + 1} of ${pdf.numPages}.`);
        let page = await pdf.getPage(pageIndex + 1);
        let viewport = await page.getViewport(1.0);
        let operators = await page.getOperatorList();

        // Indicate whether the page is rotated.

        if (page.rotate !== 0 && page.rotate !== 90)
            console.log(`Page ${pageIndex + 1} is rotated ${page.rotate}°.`);

        // Find and parse any images in the current PDF page.

        let imageInfos: ImageInfo[] = [];

        for (let index = 0; index < operators.fnArray.length; index++) {
            if (operators.fnArray[index] !== pdfjs.OPS.paintImageXObject && operators.fnArray[index] !== pdfjs.OPS.paintImageMaskXObject)
                continue;

            // The operator either contains the name of an image or an actual image.

            let image = operators.argsArray[index][0];
            if (typeof image === "string")
                image = page.objs.get(image);  // get the actual image using its name

            console.log("    Found an image.");

            // Obtain the transform that applies to the image.  Note that the first image in the
            // PDF typically has a pdfjs.OPS.dependency element in the fnArray between it and its
            // transform (pdfjs.OPS.transform).

            let transform = undefined;
            if (index - 1 >= 0 && operators.fnArray[index - 1] === pdfjs.OPS.transform)
                transform = operators.argsArray[index - 1];
            else if (index - 2 >= 0 && operators.fnArray[index - 1] === pdfjs.OPS.dependency && operators.fnArray[index - 2] === pdfjs.OPS.transform)
                transform = operators.argsArray[index - 2];
            else {
                console.log("    Could not obtain the transform for the image.");
                continue;
            }
            console.log("    Obtained the transform for the image.");

            // Use the transform to translate the X and Y co-ordinates, but assume that the width
            // and height are consistent between all images and do not need to be scaled.  This
            // is almost always the case; only the first image is sometimes an exception (with a
            // scale factor of 2.083333 instead of 4.166666).

            let bounds: Rectangle = {
                x: (transform[4] * image.height) / transform[3],
                y: ((viewport.height - transform[5] - transform[3]) * image.height) / transform[3],
                width: image.width,
                height: image.height
            };

            imageInfos.push({ image: image, bounds: bounds });
        }

        // Parse the text from the images.

        console.log(`Parsing text from ${imageInfos.length} image(s).`);

        let degrees = page.rotate;
        let pageElements: Element[] = [];
        for (let imageInfo of imageInfos) {
            pageElements = pageElements.concat(await parseImage(convertToJimpImage(imageInfo.image, degrees), rotateImage(imageInfo.bounds, degrees), "eng"));
            if (global.gc)
                global.gc();
        }

        // Try with a different page rotation (and try to use any text content).

        let applicationCount = findAllTextBounds(pageElements, "Valuation").length;
        if (findAllTextBounds(pageElements, "Valuation").length === 0) {
            degrees = (page.rotate === 0) ? 90 : 0;
            console.log(`    No development applications were found so retrying with the page rotated by ${degrees}°.`)
            pageElements = [];
            for (let imageInfo of imageInfos) {
                pageElements = pageElements.concat(await parseImage(convertToJimpImage(imageInfo.image, degrees), rotateImage(imageInfo.bounds, degrees), "eng"));
                if (global.gc)
                    global.gc();
            }

            applicationCount = findAllTextBounds(pageElements, "Valuation").length;
            if (applicationCount === 0) {
                // Get the text content.

                console.log(`    No development applications were found when the page was rotated by ${degrees}° so retrying with text content of the page.`);
                pageElements = await parseElements(page);
                applicationCount = findAllTextBounds(pageElements, "Valuation").length;
                if (applicationCount === 0)
                    console.log(`    No development applications were found in the text content of the page.`);
                else
                    console.log(`    Found ${applicationCount} ${(applicationCount === 1) ? "development application" : "development applications"} in the text content of the page.`);
            } else {
                console.log(`    Found ${applicationCount} ${(applicationCount === 1) ? "development application" : "development applications"} when the page was not rotated by ${degrees}°.`);
            }
        }

        // Release the memory used by the PDF now that it is no longer required (it will be
        // re-parsed on the next iteration of the loop for the next page).

        await pdf.destroy();
        if (global.gc)
            global.gc();

        // Ignore extremely low height elements (because these can be parsed as text but are
        // very unlikely to actually be text).  In some rare cases they may be valid (such as
        // a full stop far from other text).

        pageElements = pageElements.filter(element => element.height > 2);

        // Sort the elements by approximate Y co-ordinate and then by X co-ordinate.

        let elementComparer = (a, b) => (Math.abs(a.y - b.y) < 2 * Tolerance) ? ((a.x > b.x) ? 1 : ((a.x < b.x) ? -1 : 0)) : ((a.y > b.y) ? 1 : -1);
        pageElements.sort(elementComparer);
        
        // Find the "Permit No.", "Applicants Details, "Site of Building" and "Description of Work"
        // headings on each page.

        let pagePermitNumberHeadingBounds = findTextBounds(pageElements, "PermitNo");
        let pageApplicantsDetailsHeadingBounds = findTextBounds(pageElements, "ApplicantsDetails");
        let pageSiteOfBuildingHeadingBounds = findTextBounds(pageElements, "SiteofBuilding");
        let pageDescriptionOfWorkHeadingBounds = findTextBounds(pageElements, "DescriptionofWork");

        let topBounds = undefined;
        topBounds = (pagePermitNumberHeadingBounds === undefined || topBounds !== undefined) ? topBounds : pagePermitNumberHeadingBounds;
        topBounds = (pageApplicantsDetailsHeadingBounds === undefined || topBounds !== undefined) ? topBounds : pageApplicantsDetailsHeadingBounds;
        topBounds = (pageSiteOfBuildingHeadingBounds === undefined || topBounds !== undefined) ? topBounds : pageSiteOfBuildingHeadingBounds;
        topBounds = (pageDescriptionOfWorkHeadingBounds === undefined || topBounds !== undefined) ? topBounds : pageDescriptionOfWorkHeadingBounds;

        // Remove the heading elements.

        pageElements = pageElements.filter(element => topBounds === undefined || element.y > topBounds.y + topBounds.height);

        // Add to the overall array of all elements.

        let lowestElement = elements.reduce((previous, current) => ((previous === undefined || current.y + current.height > previous.y + previous.height) ? current : previous), undefined);
        let lowestY = (lowestElement === undefined) ? 0 : (lowestElement.y + lowestElement.height + Tolerance);
        let pageHighestElement = pageElements.reduce((previous, current) => ((previous === undefined || current.y < previous.y) ? current : previous), undefined);
        let pageHighestY = (pageHighestElement === undefined) ? 0 : pageHighestElement.y;

        for (let pageElement of pageElements)
            elements.push({ text: pageElement.text, confidence: pageElement.confidence, x: pageElement.x, y: pageElement.y - pageHighestY + lowestY, width: pageElement.width, height: pageElement.height });

        // Construct a union of the bounds of heading elements across all pages (ie. an "average").

        permitNumberHeadingBounds = union(permitNumberHeadingBounds, pagePermitNumberHeadingBounds);
        applicantsDetailsHeadingBounds = union(applicantsDetailsHeadingBounds, pageApplicantsDetailsHeadingBounds);
        siteOfBuildingHeadingBounds = union(siteOfBuildingHeadingBounds, pageSiteOfBuildingHeadingBounds);
        descriptionOfWorkHeadingBounds = union(descriptionOfWorkHeadingBounds, pageDescriptionOfWorkHeadingBounds);
    }

    return parseApplicationElements(url, elements, permitNumberHeadingBounds, applicantsDetailsHeadingBounds, siteOfBuildingHeadingBounds, descriptionOfWorkHeadingBounds);
}

// Parses the text elements from a page of a PDF.

async function parseElements(page: any) {
    let textContent = await page.getTextContent();

    // Find all the text elements.

    let elements: Element[] = textContent.items.map(item => {
        let transform = item.transform;

        // Work around the issue https://github.com/mozilla/pdf.js/issues/8276 (heights are
        // exaggerated).  The problem seems to be that the height value is too large in some
        // PDFs.  Provide an alternative, more accurate height value by using a calculation
        // based on the transform matrix.

        let workaroundHeight = Math.sqrt(transform[2] * transform[2] + transform[3] * transform[3]);

        let x = transform[4];
        let y = transform[5];
        let width = item.width;
        let height = workaroundHeight;

        return { text: item.str, x: x, y: y, width: width, height: height };
    });

    return elements;
}

// Parses development application details from the specified elements (for one application).

function parseApplicationElements(url: string, elements: Element[], permitNumberHeadingBounds: Rectangle, applicantsDetailsHeadingBounds: Rectangle, siteOfBuildingHeadingBounds: Rectangle, descriptionOfWorkHeadingBounds: Rectangle) {
    let developmentApplications = [];

    // Sort the elements by approximate Y co-ordinate and then by X co-ordinate.

    let elementComparer = (a, b) => (Math.abs(a.y - b.y) < 2 * Tolerance) ? ((a.x > b.x) ? 1 : ((a.x < b.x) ? -1 : 0)) : ((a.y > b.y) ? 1 : -1);
    elements.sort(elementComparer);

    // Search for "Valuation" as this always appears on the second line of an application (and so
    // is a good marker to use when identifying where the details of an application are located).

    let headings = findAllTextBounds(elements, "Valuation");

    for (let index = 0; index < headings.length; index++) {
        let currentHeadingY = headings[index].y - 2 * headings[index].height - Tolerance;
        let nextHeadingY = (index + 1 < headings.length) ? (headings[index + 1].y - 2 * headings[index + 1].height - Tolerance) : Number.MAX_VALUE;

        // Group the elements by development application.

        let applicationElements = elements.filter(element => element.y >= currentHeadingY && element.y < nextHeadingY);

        let applicationNumberBounds = {
            x: permitNumberHeadingBounds.x,
            y: currentHeadingY,
            width: applicantsDetailsHeadingBounds.x - permitNumberHeadingBounds.x,
            height: 2 * permitNumberHeadingBounds.height
        }

        let applicationNumber = applicationElements.filter(element => getPercentageOfElementInRectangle(element, applicationNumberBounds) > 75).map(element => element.text).join("").replace(/\s/g, "");
        if (applicationNumber === undefined || applicationNumber === "") {
            let elementSummary = applicationElements.map(element => `[${element.text}]`).join("");
            console.log(`Could not find the application number.  The development application will be ignored.  Elements: ${elementSummary}`);
            continue;
        }
    
        applicationNumber = applicationNumber.replace(/[IlL!\[\]\|\(\)\{\}]/g, "1").replace(/[°Oo]/g, "0").replace(/[‘’']/g, "").replace(/[“”]([4-9])$/g, "/1$1");
        console.log(`    Found \"${applicationNumber}\".`);
    
        // Get the address.

        let addressBounds = {
            x: siteOfBuildingHeadingBounds.x,
            y: currentHeadingY,
            width: descriptionOfWorkHeadingBounds.x - siteOfBuildingHeadingBounds.x,
            height: 3 * siteOfBuildingHeadingBounds.height
        }

        let addressElements = applicationElements.filter(element => getPercentageOfElementInRectangle(element, addressBounds) > 75);

        // Group the address elements into rows.

        let addressRows: Element[][] = [];
        for (let addressElement of addressElements) {
            let addressRow = addressRows.find(row => Math.abs(row[0].y - addressElement.y) < 2 * Tolerance);  // approximate Y co-ordinate match
            if (addressRow === undefined)
                addressRows.push([ addressElement ]);  // start a new row
            else
                addressRow.push(addressElement);  // add to an existing row
        }

        let addressText = addressElements.map(element => element.text).join("").replace(/\s/g, "");
        if (addressText === undefined || addressText === "") {
            let elementSummary = applicationElements.map(element => `[${element.text}]`).join("");
            console.log(`Application number ${applicationNumber} will be ignored because there is no address.  Elements: ${elementSummary}`);
            continue;
        }
    
        let addressLines = addressRows.map(addressRow => addressRow.map(element => element.text).join(" ").trim().replace(/\s\s+/g, " "));
        let address = addressLines.filter(line => line !== "").join(", ");  // ignore blank lines
        address = address.replace(/[‘’]/g, "'").replace(/[—*]/g, "-");
        console.log(`Address: ${address}`);

        // Get the description.
        
        let descriptionBounds = {
            x: descriptionOfWorkHeadingBounds.x,
            y: currentHeadingY,
            width: Number.MAX_VALUE,
            height: headings[index].y - currentHeadingY
        }

        let description = applicationElements.filter(element => getPercentageOfElementInRectangle(element, descriptionBounds) > 75).map(element => element.text).join(" ");
        console.log(`Description: ${description}`);

        developmentApplications.push({
            applicationNumber: applicationNumber,
            address: address,
            description: ((description === "") ? "No description provided" : description),
            informationUrl: url,
            commentUrl: CommentUrl,
            scrapeDate: moment().format("YYYY-MM-DD"),
            receivedDate: ""  // not current available in the PDFs
        });
    }

    return developmentApplications;
}

// Gets a random integer in the specified range: [minimum, maximum).

function getRandom(minimum: number, maximum: number) {
    return Math.floor(Math.random() * (Math.floor(maximum) - Math.ceil(minimum))) + Math.ceil(minimum);
}

// Pauses for the specified number of milliseconds.

function sleep(milliseconds: number) {
    return new Promise(resolve => setTimeout(resolve, milliseconds));
}

// Parses the development applications.

async function main() {
    // Ensure that the database exists.

    let database = await initializeDatabase();
    
    // Read all the street, street suffix, suburb and hundred information.

    readAddressInformation();

    // Retrieve the page that contains the links to the PDFs.

    console.log(`Retrieving page: ${DevelopmentApplicationsUrl}`);

    let body = await request({ url: DevelopmentApplicationsUrl, proxy: process.env.MORPH_PROXY });
    await sleep(2000 + getRandom(0, 5) * 1000);
    let $ = cheerio.load(body);
    
    // Add the URL of the most recent PDF.

    let pdfUrls: string[] = [];
    for (let element of $("div.unityHtmlArticle p a").get()) {
        let pdfUrl = new urlparser.URL(element.attribs.href, DevelopmentApplicationsUrl);
        if (pdfUrl.href.toLowerCase().includes("development") && (pdfUrl.href.toLowerCase().includes("approval") || pdfUrl.href.toLowerCase().includes("register")) && pdfUrl.href.toLowerCase().includes(".pdf"))
            if (!pdfUrls.some(url => url === pdfUrl.href))  // avoid duplicates
                pdfUrls.push(pdfUrl.href);
    }

    if (pdfUrls.length === 0) {
        console.log("No PDF URLs were found on the page.");
        return;
    }

    // Select the most recent PDF.  And randomly select one other PDF (avoid processing all PDFs
    // at once because this may use too much memory, resulting in morph.io terminating the current
    // process).
    
    let selectedPdfUrls: string[] = [];
    selectedPdfUrls.push(pdfUrls.shift());
    if (pdfUrls.length > 0)
        selectedPdfUrls.push(pdfUrls[getRandom(0, pdfUrls.length)]);
    if (getRandom(0, 2) === 0)
        selectedPdfUrls.reverse();

    for (let pdfUrl of selectedPdfUrls) {
        console.log(`Parsing document: ${pdfUrl}`);
        let developmentApplications = await parsePdf(pdfUrl);
        console.log(`Parsed ${developmentApplications.length} ${(developmentApplications.length === 1) ? "development application" : "development applications"} from document: ${pdfUrl}`);

        // Attempt to avoid reaching 512 MB memory usage (this will otherwise result in the
        // current process being terminated by morph.io).

        if (global.gc)
            global.gc();

        console.log(`Inserting development applications into the database.`);
        for (let developmentApplication of developmentApplications)
            await insertRow(database, developmentApplication);
    }
}

main().then(() => console.log("Complete.")).catch(error => console.error(error));
